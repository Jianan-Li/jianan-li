{"remainingRequest":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/src/components/MyGraph.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/src/components/MyGraph.vue","mtime":1550154016000},{"path":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/jianan/Library/Mobile Documents/com~apple~CloudDocs/Jianan/Projects/websites/jianan-li/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport * as d3 from \"d3\";\n\nexport default {\n  name: \"MyGraph\",\n  data: () => ({\n    previousWindowWidth: null,\n    width: null,\n    height: null,\n    gridSize: 100,\n    selections: {},\n    pathStrokeWidth: [1.5, 1.25, 1, 1],\n    circleSizes: [44, 37, 33, 30, 30],\n    fontSizes: [25, 15, 12, 11, 11],\n    linkColor: \"#ffffff\",\n    nonLinkColor: \"#000000\",\n    enlargeRatioOnHover: 2,\n    patterns: [\"Andrew\", \"Jordan\"],\n    simulation: null,\n    zoom: null,\n    forceProperties: {\n      center: {\n        x: 0.5,\n        y: 0.5\n      },\n      charge: {\n        enabled: true,\n        strength: -2000,\n        distanceMin: 1,\n        distanceMax: 2000\n      },\n      collide: {\n        enabled: true,\n        strength: 1,\n        iterations: 1,\n        radius: 55\n      },\n      forceX: {\n        enabled: true,\n        strength: 0.18,\n        x: 0.5\n      },\n      forceY: {\n        enabled: true,\n        strength: 0.28,\n        y: 0.5\n      },\n      link: {\n        enabled: true,\n        distance: 35,\n        iterations: 1\n      }\n    },\n    data: {\n      nodes: [],\n      links: []\n    }\n  }),\n  computed: {\n    innerGridSize() {\n      return this.gridSize / 10;\n    },\n    nodes() {\n      return this.data.nodes;\n    },\n    links() {\n      return this.data.links;\n    }\n  },\n  created() {},\n  mounted() {\n    // Get initial width when things are mounted\n    // also add listener for width change\n    this.width = document.getElementById(\"interests\").clientWidth;\n    this.height = (this.width * 2) / 3;\n    // this.height = this.width>576? (this.width * 2) / 3 : this.width;\n    window.addEventListener(\"resize\", this.resizeCanvas);\n\n    // Attach event listener to prevent scrolling inside the nodes graph\n    // document.getElementById(\"nodes\").addEventListener(\"wheel\", this.scrollListener);\n\n    // Moved here from created\n    this.simulation = d3\n      .forceSimulation()\n      .force(\"link\", d3.forceLink())\n      .force(\"charge\", d3.forceManyBody())\n      .force(\"collide\", d3.forceCollide())\n      .force(\"center\", d3.forceCenter())\n      .force(\"forceX\", d3.forceX())\n      .force(\"forceY\", d3.forceY())\n      .on(\"tick\", this.tick);\n    // Call first time to setup default values\n    this.updateForces();\n\n    this.selections.svg = d3.select(this.$el.querySelector(\"svg\"));\n    const svg = this.selections.svg;\n\n    // Add zoom and panning triggers\n    this.zoom = d3\n      .zoom()\n      .scaleExtent([1 / 3, 2])\n      .on(\"zoom\", this.zoomed);\n    svg.call(this.zoom);\n\n    // A background grid to help user experience\n    // The width and height depends on the minimum scale extent and\n    // the + 10% and negative index to create an infinite grid feel\n    // The precedence of this element is important since you'll have\n    // click events on the elements above the grid\n    // this.selections.grid = svg\n    //   .append(\"rect\")\n    //   .attr(\"x\", \"-50%\")\n    //   .attr(\"y\", \"-50%\")\n    //   .attr(\"width\", \"450%\")\n    //   .attr(\"height\", \"450%\")\n    //   .attr(\"fill\", \"url(#grid)\");\n\n    this.selections.graph = svg.append(\"g\");\n    // const graph = this.selections.graph;\n\n    // You can set data in any ways you want\n    d3.json(\"/mydata.json\")\n      .then(data => {\n        this.data = data;\n      })\n      .catch(error => {\n        // eslint-disable-next-line\n        console.error(`Failed to retrieve data. Error: ${error}`);\n      });\n  },\n  beforeDestroy: function() {\n    window.removeEventListener(\"resize\", this.resizeCanvas);\n    // document.getElementById(\"nodes\").removeEventListener(\"wheel\", this.scrollListener);\n  },\n  methods: {\n    tick() {\n      // only run when the graph is moving, stops when the graph settles\n      const transform = d => {\n        // return \"translate(\" + Math.max(30, Math.min(this.width - 30, d.x)) + \",\" + Math.max(30, Math.min(this.height - 30, d.y)) + \")\";\n        return \"translate(\" + d.x + \",\" + d.y + \")\";\n      };\n\n      const link = d => {\n        return (\n          \"M\" +\n          d.source.x +\n          \",\" +\n          d.source.y +\n          \" L\" +\n          d.target.x +\n          \",\" +\n          d.target.y\n        );\n      };\n\n      const graph = this.selections.graph;\n      graph.selectAll(\"path\").attr(\"d\", link);\n      graph.selectAll(\"circle\").attr(\"transform\", transform);\n      graph.selectAll(\"text\").attr(\"transform\", transform);\n    },\n    updateData() {\n      this.simulation.nodes(this.nodes);\n      this.simulation.force(\"link\").links(this.links);\n\n      const simulation = this.simulation;\n      const graph = this.selections.graph;\n\n      // Links should only exit if not needed anymore\n      graph\n        .selectAll(\"path\")\n        .data(this.links)\n        .exit()\n        .remove();\n\n      graph\n        .selectAll(\"path\")\n        .data(this.links)\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", \"link\")\n        .attr(\"stroke-width\", l => this.pathStrokeWidth[l.value]);\n\n      // Nodes should always be redrawn to avoid lines above them\n      graph.select(\"#circles\").remove();\n      graph.selectAll(\"circle\").remove();\n\n      // const circles = graph.append(\"g\").attr(\"id\", \"circles\");\n      graph\n        .append(\"g\")\n        .attr(\"id\", \"circles\")\n        // .attr(\"filter\", \"url(#f3)\")\n        .selectAll(\"circle\")\n        .data(this.nodes)\n        .enter()\n        .append(\"circle\")\n        .attr(\"r\", d => this.circleSizes[d.group])\n        .attr(\"class\", d =>\n          d.link ? \" my-graph-circle url\" : \"my-graph-circle nonurl\"\n        )\n        .call(\n          d3\n            .drag()\n            .on(\"start\", this.nodeDragStarted)\n            .on(\"drag\", this.nodeDragged)\n            .on(\"end\", this.nodeDragEnded)\n        )\n        .on(\"mouseover\", this.nodeMouseOver)\n        .on(\"mouseout\", this.nodeMouseOut)\n        .on(\"click\", this.nodeClick);\n\n      graph.selectAll(\"text\").remove();\n\n      let textRegion = graph\n        .selectAll(\"text\")\n        .data(this.nodes)\n        .enter();\n      textRegion\n        .filter(d => d.name)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.14em\") //.31em\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name);\n      textRegion\n        .filter(d => d.name1)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"-0.41em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name1);\n      textRegion\n        .filter(d => d.name2)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.69em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name2);\n      textRegion\n        .filter(d => d.name3)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"-0.96em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name3);\n      textRegion\n        .filter(d => d.name4)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.14em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name4);\n      textRegion\n        .filter(d => d.name5)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"1.24em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name5);\n\n      simulation.alpha(1).restart();\n    },\n    updateForces() {\n      const { simulation, forceProperties, width, height } = this;\n      simulation\n        .force(\"center\")\n        .x(width * forceProperties.center.x)\n        .y(height * forceProperties.center.y);\n      simulation\n        .force(\"charge\")\n        .strength(\n          forceProperties.charge.strength * forceProperties.charge.enabled\n        )\n        .distanceMin(forceProperties.charge.distanceMin)\n        .distanceMax(forceProperties.charge.distanceMax);\n      simulation\n        .force(\"collide\")\n        .strength(\n          forceProperties.collide.strength * forceProperties.collide.enabled\n        )\n        .radius(forceProperties.collide.radius)\n        .iterations(forceProperties.collide.iterations);\n      simulation\n        .force(\"forceX\")\n        .strength(\n          forceProperties.forceX.strength * forceProperties.forceX.enabled\n        )\n        .x(width * forceProperties.forceX.x);\n      simulation\n        .force(\"forceY\")\n        .strength(\n          forceProperties.forceY.strength * forceProperties.forceY.enabled\n        )\n        .y(height * forceProperties.forceY.y);\n      simulation\n        .force(\"link\")\n        .distance(forceProperties.link.distance)\n        .iterations(forceProperties.link.iterations);\n\n      // updates ignored until this is run\n      // restarts the simulation (important if simulation has already slowed down)\n      simulation.alpha(1).restart();\n    },\n    zoomed() {\n      const transform = d3.event.transform;\n      // The trick here is to move the grid in a way that the user doesn't perceive\n      // that the axis aren't really moving\n      // The actual movement is between 0 and gridSize only for x and y\n      // const translate =\n      //   (transform.x % (this.gridSize * transform.k)) +\n      //   \",\" +\n      //   (transform.y % (this.gridSize * transform.k));\n      // this.selections.grid.attr(\n      //   \"transform\",\n      //   \"translate(\" + translate + \") scale(\" + transform.k + \")\"\n      // );\n      this.selections.graph.attr(\"transform\", transform);\n\n      // Define some world boundaries based on the graph total size\n      // so we don't scroll indefinitely\n      const graphBox = this.selections.graph.node().getBBox();\n      // console.log(`graphBox.x: ${graphBox.x}`);\n      // console.log(`graphBox.y: ${graphBox.y}`);\n      // console.log(`graphBox.width: ${graphBox.width}`);\n      // console.log(`graphBox.height: ${graphBox.height}`);\n      const margin_x = 8000;\n      const total_x = graphBox.width + 2 * margin_x;\n      const total_y = (total_x / 3) * 2;\n      const margin_y = (total_y - graphBox.height) / 2;\n      const worldTopLeft = [graphBox.x - margin_x, graphBox.y - margin_y];\n      const worldBottomRight = [\n        graphBox.x + graphBox.width + margin_x,\n        graphBox.y + graphBox.height + margin_y\n      ];\n      this.zoom.translateExtent([worldTopLeft, worldBottomRight]);\n    },\n    nodeDragStarted(d) {\n      if (!d3.event.active) {\n        this.simulation.alphaTarget(0.3).restart();\n      }\n      d.fx = d.x;\n      d.fy = d.y;\n    },\n    nodeDragged(d) {\n      d.fx = d3.event.x;\n      d.fy = d3.event.y;\n    },\n    nodeDragEnded(d) {\n      if (!d3.event.active) {\n        this.simulation.alphaTarget(0.0001);\n      }\n      d.fx = null;\n      d.fy = null;\n    },\n    nodeMouseOver(d) {\n      if (d.link) {\n        const allCircles = this.selections.graph.selectAll(\"circle\");\n        const allText = this.selections.graph.selectAll(\"text\");\n        const mouseOverCircle = allCircles.filter(td => td === d);\n        const mouseOverText = allText.filter(td => td === d);\n        allCircles.classed(\"hover\", false);\n        mouseOverCircle.classed(\"hover\", true);\n        mouseOverCircle\n          // .style(\"fill\", d => (this.patterns.indexOf(d.name1) >= 0)? `url(#${d.name1})`:\"\")\n          .transition()\n          .ease(d3.easeElastic)\n          .duration(800)\n          .attr(\"r\", this.circleSizes[d.group] * this.enlargeRatioOnHover);\n        // .attr(\"transform\", \"scale(1.5)\")\n\n        // d3.select(\"#Jordan-img\")\n        //   .transition()\n        //   .ease(d3.easeElastic)\n        //   .duration(800)\n        //   .attr(\"transform\", \"scale(2.25)\")\n        // .attr(\"x\", \"0\")\n        // .attr(\"y\", \"0\")\n\n        mouseOverText\n          .transition()\n          .ease(d3.easeElastic)\n          .duration(800)\n          // .attr(\"x\", 0)\n          // .attr(\"fill\", \"#ffffff\")\n          // .attr(\"fill-opacity\", \"0\")\n          .attr(\n            \"font-size\",\n            d => this.fontSizes[d.group] * this.enlargeRatioOnHover\n          );\n      }\n    },\n    nodeMouseOut(d) {\n      const allCircles = this.selections.graph.selectAll(\"circle\");\n      const allText = this.selections.graph.selectAll(\"text\");\n      const mouseOutCircle = allCircles.filter(td => td === d);\n      const mouseOutText = allText.filter(td => td === d);\n      allCircles.classed(\"hover\", false);\n      mouseOutCircle\n        .transition()\n        .ease(d3.easeElastic)\n        .duration(800)\n        .attr(\"r\", d => this.circleSizes[d.group]);\n      // .style(\"fill\", d => \"\")\n\n      // d3.select(\"#Jordan-img\")\n      //   .transition()\n      //   .ease(d3.easeElastic)\n      //   .duration(800)\n      // .attr(\"transform\", \"scale(0.66667)\")\n\n      mouseOutText\n        .transition()\n        .ease(d3.easeElastic)\n        .duration(800)\n        // .attr(\"x\", 0)\n        // .attr(\"y\", \"0.31em\")\n        // .attr(\"fill-opacity\", \"1\")\n        .attr(\"font-size\", d => this.fontSizes[d.group]);\n    },\n    nodeClick(d) {\n      if (d.link) {\n        window.open(d.link);\n      }\n    },\n    resizeCanvas() {\n      if (window.innerWidth != this.previousWindowWidth) {\n        this.width = document.getElementById(\"interests\").clientWidth;\n        this.height = (this.width * 2) / 3;\n        // this.height = this.width>576? (this.width * 2) / 3 : this.width;\n        this.previousWindowWidth = window.innerWidth;\n\n        // Update the centering force\n        // update center location, then restart simulation\n        // otherwise, if cooled down already, won't be responsive\n        const { simulation, forceProperties, width, height } = this;\n        simulation\n          .force(\"center\")\n          .x(width * forceProperties.center.x)\n          .y(height * forceProperties.center.y);\n        simulation\n          .force(\"forceX\")\n          .strength(\n            forceProperties.forceX.strength * forceProperties.forceX.enabled\n          )\n          .x(width * forceProperties.forceX.x);\n        simulation\n          .force(\"forceY\")\n          .strength(\n            forceProperties.forceY.strength * forceProperties.forceY.enabled\n          )\n          .y(height * forceProperties.forceY.y);\n        simulation.alpha(1).restart();\n      }\n    },\n    scrollListener(e) {\n      e.preventDefault();\n    }\n  },\n  watch: {\n    data: {\n      handler() {\n        this.updateData();\n      },\n      deep: true\n    },\n    forceProperties: {\n      handler() {\n        this.updateForces();\n      },\n      deep: true\n    }\n  }\n};\n",{"version":3,"sources":["MyGraph.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"MyGraph.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div\n    class=\"my-graph\"\n    :style=\"{\n      width: '100%',\n      height: height + 'px'\n    }\"\n  >\n    <svg :width=\"width\" :height=\"height\" class=\"my-graph-svg cutout\">\n      <defs>\n        <!-- <filter id=\"f3\" x=\"0\" y=\"0\" width=\"130%\" height=\"130%\">\n          <feOffset result=\"offOut\" in=\"SourceAlpha\" dx=\"2\" dy=\"2\" />\n          <feGaussianBlur result=\"blurOut\" in=\"offOut\" stdDeviation=\"3\" />\n          <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" />\n        </filter> -->\n        <filter id=\"dropshadow\" x=\"0\" y=\"0\" width=\"130%\" height=\"130%\">\n          <feGaussianBlur in=\"SourceAlpha\" stdDeviation=\"3\" result=\"blur\" />\n          <!-- stdDeviation is how much to blur -->\n          <feOffset dx=\"2\" dy=\"2\" result=\"offset-blur\" />\n          <!-- how much to offset -->\n          <feComponentTransfer>\n            <feFuncA type=\"linear\" slope=\"0.4\" result=\"offset-opacity-blur\" />\n            <!-- slope is the opacity of the shadow -->\n          </feComponentTransfer>\n          <feMerge>\n            <feMergeNode in=\"offset-opacity-blur\" />\n            <!-- this contains the offset blurred image -->\n            <feMergeNode in=\"SourceGraphic\" />\n            <!-- this contains the element that the filter is applied to -->\n          </feMerge>\n        </filter>\n        <!-- <pattern id=\"Andrew\" x=\"0\" y=\"0\" height=\"1\" width=\"1\">\n          <image\n            x=\"0\"\n            y=\"0\"\n            width=\"60\"\n            height=\"60\"\n            xlink:href=\"https://yt3.ggpht.com/a-/AN66SAzs8DmwITc00osvw7xV_blFvWfisegTxaxhVw=s288-mo-c-c0xffffffff-rj-k-no\"\n          ></image>\n        </pattern>\n        <pattern id=\"Jordan\" x=\"0\" y=\"0\" height=\"1\" width=\"1\">\n          <image\n            id=\"Jordan-img\"\n            x=\"0\"\n            y=\"0\"\n            width=\"44\"\n            height=\"44\"\n            :xlink:href=\"require(`@/assets/avatars/jordan.png`)\"\n          ></image>\n        </pattern> -->\n        <pattern\n          id=\"innerGrid\"\n          :width=\"innerGridSize\"\n          :height=\"innerGridSize\"\n          patternUnits=\"userSpaceOnUse\"\n        >\n          <rect\n            width=\"100%\"\n            height=\"100%\"\n            fill=\"none\"\n            stroke=\"#CCCCCC7A\"\n            stroke-width=\"0.5\"\n          />\n        </pattern>\n        <pattern\n          id=\"grid\"\n          :width=\"gridSize\"\n          :height=\"gridSize\"\n          patternUnits=\"userSpaceOnUse\"\n        >\n          <rect\n            width=\"100%\"\n            height=\"100%\"\n            fill=\"url(#innerGrid)\"\n            stroke=\"#CCCCCC7A\"\n            stroke-width=\"1.5\"\n          />\n        </pattern>\n      </defs>\n    </svg>\n  </div>\n</template>\n\n<script>\nimport * as d3 from \"d3\";\n\nexport default {\n  name: \"MyGraph\",\n  data: () => ({\n    previousWindowWidth: null,\n    width: null,\n    height: null,\n    gridSize: 100,\n    selections: {},\n    pathStrokeWidth: [1.5, 1.25, 1, 1],\n    circleSizes: [44, 37, 33, 30, 30],\n    fontSizes: [25, 15, 12, 11, 11],\n    linkColor: \"#ffffff\",\n    nonLinkColor: \"#000000\",\n    enlargeRatioOnHover: 2,\n    patterns: [\"Andrew\", \"Jordan\"],\n    simulation: null,\n    zoom: null,\n    forceProperties: {\n      center: {\n        x: 0.5,\n        y: 0.5\n      },\n      charge: {\n        enabled: true,\n        strength: -2000,\n        distanceMin: 1,\n        distanceMax: 2000\n      },\n      collide: {\n        enabled: true,\n        strength: 1,\n        iterations: 1,\n        radius: 55\n      },\n      forceX: {\n        enabled: true,\n        strength: 0.18,\n        x: 0.5\n      },\n      forceY: {\n        enabled: true,\n        strength: 0.28,\n        y: 0.5\n      },\n      link: {\n        enabled: true,\n        distance: 35,\n        iterations: 1\n      }\n    },\n    data: {\n      nodes: [],\n      links: []\n    }\n  }),\n  computed: {\n    innerGridSize() {\n      return this.gridSize / 10;\n    },\n    nodes() {\n      return this.data.nodes;\n    },\n    links() {\n      return this.data.links;\n    }\n  },\n  created() {},\n  mounted() {\n    // Get initial width when things are mounted\n    // also add listener for width change\n    this.width = document.getElementById(\"interests\").clientWidth;\n    this.height = (this.width * 2) / 3;\n    // this.height = this.width>576? (this.width * 2) / 3 : this.width;\n    window.addEventListener(\"resize\", this.resizeCanvas);\n\n    // Attach event listener to prevent scrolling inside the nodes graph\n    // document.getElementById(\"nodes\").addEventListener(\"wheel\", this.scrollListener);\n\n    // Moved here from created\n    this.simulation = d3\n      .forceSimulation()\n      .force(\"link\", d3.forceLink())\n      .force(\"charge\", d3.forceManyBody())\n      .force(\"collide\", d3.forceCollide())\n      .force(\"center\", d3.forceCenter())\n      .force(\"forceX\", d3.forceX())\n      .force(\"forceY\", d3.forceY())\n      .on(\"tick\", this.tick);\n    // Call first time to setup default values\n    this.updateForces();\n\n    this.selections.svg = d3.select(this.$el.querySelector(\"svg\"));\n    const svg = this.selections.svg;\n\n    // Add zoom and panning triggers\n    this.zoom = d3\n      .zoom()\n      .scaleExtent([1 / 3, 2])\n      .on(\"zoom\", this.zoomed);\n    svg.call(this.zoom);\n\n    // A background grid to help user experience\n    // The width and height depends on the minimum scale extent and\n    // the + 10% and negative index to create an infinite grid feel\n    // The precedence of this element is important since you'll have\n    // click events on the elements above the grid\n    // this.selections.grid = svg\n    //   .append(\"rect\")\n    //   .attr(\"x\", \"-50%\")\n    //   .attr(\"y\", \"-50%\")\n    //   .attr(\"width\", \"450%\")\n    //   .attr(\"height\", \"450%\")\n    //   .attr(\"fill\", \"url(#grid)\");\n\n    this.selections.graph = svg.append(\"g\");\n    // const graph = this.selections.graph;\n\n    // You can set data in any ways you want\n    d3.json(\"/mydata.json\")\n      .then(data => {\n        this.data = data;\n      })\n      .catch(error => {\n        // eslint-disable-next-line\n        console.error(`Failed to retrieve data. Error: ${error}`);\n      });\n  },\n  beforeDestroy: function() {\n    window.removeEventListener(\"resize\", this.resizeCanvas);\n    // document.getElementById(\"nodes\").removeEventListener(\"wheel\", this.scrollListener);\n  },\n  methods: {\n    tick() {\n      // only run when the graph is moving, stops when the graph settles\n      const transform = d => {\n        // return \"translate(\" + Math.max(30, Math.min(this.width - 30, d.x)) + \",\" + Math.max(30, Math.min(this.height - 30, d.y)) + \")\";\n        return \"translate(\" + d.x + \",\" + d.y + \")\";\n      };\n\n      const link = d => {\n        return (\n          \"M\" +\n          d.source.x +\n          \",\" +\n          d.source.y +\n          \" L\" +\n          d.target.x +\n          \",\" +\n          d.target.y\n        );\n      };\n\n      const graph = this.selections.graph;\n      graph.selectAll(\"path\").attr(\"d\", link);\n      graph.selectAll(\"circle\").attr(\"transform\", transform);\n      graph.selectAll(\"text\").attr(\"transform\", transform);\n    },\n    updateData() {\n      this.simulation.nodes(this.nodes);\n      this.simulation.force(\"link\").links(this.links);\n\n      const simulation = this.simulation;\n      const graph = this.selections.graph;\n\n      // Links should only exit if not needed anymore\n      graph\n        .selectAll(\"path\")\n        .data(this.links)\n        .exit()\n        .remove();\n\n      graph\n        .selectAll(\"path\")\n        .data(this.links)\n        .enter()\n        .append(\"path\")\n        .attr(\"class\", \"link\")\n        .attr(\"stroke-width\", l => this.pathStrokeWidth[l.value]);\n\n      // Nodes should always be redrawn to avoid lines above them\n      graph.select(\"#circles\").remove();\n      graph.selectAll(\"circle\").remove();\n\n      // const circles = graph.append(\"g\").attr(\"id\", \"circles\");\n      graph\n        .append(\"g\")\n        .attr(\"id\", \"circles\")\n        // .attr(\"filter\", \"url(#f3)\")\n        .selectAll(\"circle\")\n        .data(this.nodes)\n        .enter()\n        .append(\"circle\")\n        .attr(\"r\", d => this.circleSizes[d.group])\n        .attr(\"class\", d =>\n          d.link ? \" my-graph-circle url\" : \"my-graph-circle nonurl\"\n        )\n        .call(\n          d3\n            .drag()\n            .on(\"start\", this.nodeDragStarted)\n            .on(\"drag\", this.nodeDragged)\n            .on(\"end\", this.nodeDragEnded)\n        )\n        .on(\"mouseover\", this.nodeMouseOver)\n        .on(\"mouseout\", this.nodeMouseOut)\n        .on(\"click\", this.nodeClick);\n\n      graph.selectAll(\"text\").remove();\n\n      let textRegion = graph\n        .selectAll(\"text\")\n        .data(this.nodes)\n        .enter();\n      textRegion\n        .filter(d => d.name)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.14em\") //.31em\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name);\n      textRegion\n        .filter(d => d.name1)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"-0.41em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name1);\n      textRegion\n        .filter(d => d.name2)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.69em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name2);\n      textRegion\n        .filter(d => d.name3)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"-0.96em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name3);\n      textRegion\n        .filter(d => d.name4)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"0.14em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name4);\n      textRegion\n        .filter(d => d.name5)\n        .append(\"text\")\n        .attr(\"x\", \"0em\")\n        .attr(\"y\", \"1.24em\")\n        .attr(\"font-size\", d => this.fontSizes[d.group])\n        .attr(\"fill\", d => (d.link ? this.linkColor : this.nonLinkColor))\n        .attr(\"text-anchor\", \"middle\")\n        .attr(\"dominant-baseline\", \"middle\")\n        .text(d => d.name5);\n\n      simulation.alpha(1).restart();\n    },\n    updateForces() {\n      const { simulation, forceProperties, width, height } = this;\n      simulation\n        .force(\"center\")\n        .x(width * forceProperties.center.x)\n        .y(height * forceProperties.center.y);\n      simulation\n        .force(\"charge\")\n        .strength(\n          forceProperties.charge.strength * forceProperties.charge.enabled\n        )\n        .distanceMin(forceProperties.charge.distanceMin)\n        .distanceMax(forceProperties.charge.distanceMax);\n      simulation\n        .force(\"collide\")\n        .strength(\n          forceProperties.collide.strength * forceProperties.collide.enabled\n        )\n        .radius(forceProperties.collide.radius)\n        .iterations(forceProperties.collide.iterations);\n      simulation\n        .force(\"forceX\")\n        .strength(\n          forceProperties.forceX.strength * forceProperties.forceX.enabled\n        )\n        .x(width * forceProperties.forceX.x);\n      simulation\n        .force(\"forceY\")\n        .strength(\n          forceProperties.forceY.strength * forceProperties.forceY.enabled\n        )\n        .y(height * forceProperties.forceY.y);\n      simulation\n        .force(\"link\")\n        .distance(forceProperties.link.distance)\n        .iterations(forceProperties.link.iterations);\n\n      // updates ignored until this is run\n      // restarts the simulation (important if simulation has already slowed down)\n      simulation.alpha(1).restart();\n    },\n    zoomed() {\n      const transform = d3.event.transform;\n      // The trick here is to move the grid in a way that the user doesn't perceive\n      // that the axis aren't really moving\n      // The actual movement is between 0 and gridSize only for x and y\n      // const translate =\n      //   (transform.x % (this.gridSize * transform.k)) +\n      //   \",\" +\n      //   (transform.y % (this.gridSize * transform.k));\n      // this.selections.grid.attr(\n      //   \"transform\",\n      //   \"translate(\" + translate + \") scale(\" + transform.k + \")\"\n      // );\n      this.selections.graph.attr(\"transform\", transform);\n\n      // Define some world boundaries based on the graph total size\n      // so we don't scroll indefinitely\n      const graphBox = this.selections.graph.node().getBBox();\n      // console.log(`graphBox.x: ${graphBox.x}`);\n      // console.log(`graphBox.y: ${graphBox.y}`);\n      // console.log(`graphBox.width: ${graphBox.width}`);\n      // console.log(`graphBox.height: ${graphBox.height}`);\n      const margin_x = 8000;\n      const total_x = graphBox.width + 2 * margin_x;\n      const total_y = (total_x / 3) * 2;\n      const margin_y = (total_y - graphBox.height) / 2;\n      const worldTopLeft = [graphBox.x - margin_x, graphBox.y - margin_y];\n      const worldBottomRight = [\n        graphBox.x + graphBox.width + margin_x,\n        graphBox.y + graphBox.height + margin_y\n      ];\n      this.zoom.translateExtent([worldTopLeft, worldBottomRight]);\n    },\n    nodeDragStarted(d) {\n      if (!d3.event.active) {\n        this.simulation.alphaTarget(0.3).restart();\n      }\n      d.fx = d.x;\n      d.fy = d.y;\n    },\n    nodeDragged(d) {\n      d.fx = d3.event.x;\n      d.fy = d3.event.y;\n    },\n    nodeDragEnded(d) {\n      if (!d3.event.active) {\n        this.simulation.alphaTarget(0.0001);\n      }\n      d.fx = null;\n      d.fy = null;\n    },\n    nodeMouseOver(d) {\n      if (d.link) {\n        const allCircles = this.selections.graph.selectAll(\"circle\");\n        const allText = this.selections.graph.selectAll(\"text\");\n        const mouseOverCircle = allCircles.filter(td => td === d);\n        const mouseOverText = allText.filter(td => td === d);\n        allCircles.classed(\"hover\", false);\n        mouseOverCircle.classed(\"hover\", true);\n        mouseOverCircle\n          // .style(\"fill\", d => (this.patterns.indexOf(d.name1) >= 0)? `url(#${d.name1})`:\"\")\n          .transition()\n          .ease(d3.easeElastic)\n          .duration(800)\n          .attr(\"r\", this.circleSizes[d.group] * this.enlargeRatioOnHover);\n        // .attr(\"transform\", \"scale(1.5)\")\n\n        // d3.select(\"#Jordan-img\")\n        //   .transition()\n        //   .ease(d3.easeElastic)\n        //   .duration(800)\n        //   .attr(\"transform\", \"scale(2.25)\")\n        // .attr(\"x\", \"0\")\n        // .attr(\"y\", \"0\")\n\n        mouseOverText\n          .transition()\n          .ease(d3.easeElastic)\n          .duration(800)\n          // .attr(\"x\", 0)\n          // .attr(\"fill\", \"#ffffff\")\n          // .attr(\"fill-opacity\", \"0\")\n          .attr(\n            \"font-size\",\n            d => this.fontSizes[d.group] * this.enlargeRatioOnHover\n          );\n      }\n    },\n    nodeMouseOut(d) {\n      const allCircles = this.selections.graph.selectAll(\"circle\");\n      const allText = this.selections.graph.selectAll(\"text\");\n      const mouseOutCircle = allCircles.filter(td => td === d);\n      const mouseOutText = allText.filter(td => td === d);\n      allCircles.classed(\"hover\", false);\n      mouseOutCircle\n        .transition()\n        .ease(d3.easeElastic)\n        .duration(800)\n        .attr(\"r\", d => this.circleSizes[d.group]);\n      // .style(\"fill\", d => \"\")\n\n      // d3.select(\"#Jordan-img\")\n      //   .transition()\n      //   .ease(d3.easeElastic)\n      //   .duration(800)\n      // .attr(\"transform\", \"scale(0.66667)\")\n\n      mouseOutText\n        .transition()\n        .ease(d3.easeElastic)\n        .duration(800)\n        // .attr(\"x\", 0)\n        // .attr(\"y\", \"0.31em\")\n        // .attr(\"fill-opacity\", \"1\")\n        .attr(\"font-size\", d => this.fontSizes[d.group]);\n    },\n    nodeClick(d) {\n      if (d.link) {\n        window.open(d.link);\n      }\n    },\n    resizeCanvas() {\n      if (window.innerWidth != this.previousWindowWidth) {\n        this.width = document.getElementById(\"interests\").clientWidth;\n        this.height = (this.width * 2) / 3;\n        // this.height = this.width>576? (this.width * 2) / 3 : this.width;\n        this.previousWindowWidth = window.innerWidth;\n\n        // Update the centering force\n        // update center location, then restart simulation\n        // otherwise, if cooled down already, won't be responsive\n        const { simulation, forceProperties, width, height } = this;\n        simulation\n          .force(\"center\")\n          .x(width * forceProperties.center.x)\n          .y(height * forceProperties.center.y);\n        simulation\n          .force(\"forceX\")\n          .strength(\n            forceProperties.forceX.strength * forceProperties.forceX.enabled\n          )\n          .x(width * forceProperties.forceX.x);\n        simulation\n          .force(\"forceY\")\n          .strength(\n            forceProperties.forceY.strength * forceProperties.forceY.enabled\n          )\n          .y(height * forceProperties.forceY.y);\n        simulation.alpha(1).restart();\n      }\n    },\n    scrollListener(e) {\n      e.preventDefault();\n    }\n  },\n  watch: {\n    data: {\n      handler() {\n        this.updateData();\n      },\n      deep: true\n    },\n    forceProperties: {\n      handler() {\n        this.updateForces();\n      },\n      deep: true\n    }\n  }\n};\n</script>\n\n<style>\n.my-graph {\n  padding-top: 3rem;\n}\n@media screen and (max-width: 600px) {\n  .my-graph {\n    padding-top: 1rem;\n  }\n}\n.faded {\n  opacity: 0.1;\n  transition: 0.3s opacity;\n}\n.highlight {\n  opacity: 1;\n}\npath.link {\n  fill: none;\n  stroke: #aaaaaa;\n}\ncircle.my-graph-circle {\n  transition: 0.3s fill;\n  stroke-width: 1px;\n  fill: #eeeeee;\n  opacity: 0.9;\n}\ncircle.url {\n  fill: #004e79;\n}\ncircle.hover {\n  cursor: pointer;\n  fill: #0085ce;\n  transition: 0.3s fill;\n}\ntext {\n  /* font: 12px FuturaPT; */\n  pointer-events: none;\n}\n</style>\n"]}]}